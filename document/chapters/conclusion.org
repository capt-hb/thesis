* Conclusions
  The semantics of the uninitialized capabilities were described at the beginning of the thesis.
  After describing the semantics of unitialized capabilities, the ISA extension for uninitialized
  capabilities was described. This ISA extension was then instantiated for CHERI-MIPS in software
  (using a simulator). Uninitialized capabilities have not been added in hardware and is out of the
  scope if this thesis. I do believe it should be possible to implement them in hardware, the
  reasoning behind this is that unitialized capabilities only require one bit to indicate if a 
  capability is uninitialized or not, and there are some padding bits available in the 256-bit capability
  format. Other formats should be possible to but are more complicated due to the compression techniques
  used. The instruction modifications and new instructions seem plausible in hardware, they have
  existing counterparts (the normal store instructions and set bounds instruction) and because these
  could be implemented in hardware, it seems safe to say that the ones introduced by this thesis should
  be as well.
  
  A modified version of the calling convention with local capabilities, using uninitialized capabilities
  as well, is described in detail. This calling convention is more secure than existing alternatives
  but at the cost of some overhead due to stack and register clearing requirements. 
  # TODO: evaluation performance results: some overhead or significant overhead? (sentence above)
  The assembler of the LLVM project (for the MIPS backend) was modified to support the uninitialized
  capability instructions. The assembler was then used to evaluate the instructions and the secure
  calling convention.
  # TODO
  # Evaluation results summary
  
  Finally, an exploration of the modifications needed to the CLang/LLVM compiler were outlined and
  discussed. Although there was not enough time to implement these myself, the exploration should
  provide useful in future work, be it building on this thesis and finishing the implementation of
  the calling convention or for adding other calling conventions to the CLang/LLVM compiler.
