* Evaluation
  Two kinds of evaluation were performed, the first one being the unit testing of instructions,
  for the modified and new instructions. The second evaluation is concerned with the new calling
  convention and how it compares to the calling convention currently in use on CHERI-MIPS.
  
  For both evaluations the same testing infrastructure is used. The tests are added to a fork of the
  cheritest[fn:cheritest] repository. The cheritest repository[fn:cheritest-original], developed by 
  the researchers behind CHERI, makes it easy to run tests on the CHERI-MIPS simulator. Tests are
  defined by an assembly file and python file (both must have the same name, only the file extension
  should differ). The python file is used to make the test assertions
  based on the log file produced by running the machine code (compiled from the assembly file) on
  the CHERI-MIPS simulator. The log file contains the contents of the registers (both the 
  general-purpose registers and the capability registers), how many instructions were executed,
  the time elapsed for running the instructions (in nanoseconds), how many instructions were executed
  per second and some other information that is of less relevance for the evaluation.
  
  The following sections will mention where the tests can be found, this is for the fork of the 
  cheritest repository[fn:cheritest]. The tests are run on the C simulator of CHERI-MIPS, as 
  generated by Sail.
  
# * CHERITest: Modifying the Calling Convention
#  Explain the setup for these tests carefully, compiling C examples into CHERI-MIPS assembly.

# ** Current Calling Convention
#   Show how the current calling convention works, a good starting point for this is the diagrams
#   created for the simple_call.s file.
   
# ** Calling Convention with Uninitialized Capabilities
#   Show the modifications made to the original calling convention, how these use uninit caps
#   and mention that both assembly programs maintain the original semantics of the C program.
[fn:cheritest]https://github.com/capt-hb/cheritest
[fn:cheritest-original]Original cheritest repository: https://github.com/CTSRD-CHERI/cheritest

** Unit Testing Instructions
   The unit tests for the modified and new instructions can be found in /tests/uninitialized_capabilities/.
   These tests are focused on the behavior of the instructions and they all pass.
   I will not go over each test individually, this would become rather tedious to read, a small
   description of each test file can be found in Table \ref{tab:unit-tests-description}.
   
   #+NAME: tab:unit-tests-description
   #+CAPTION: Unit tests with small description
   | Test File                    | Description                                                                |
   |------------------------------+----------------------------------------------------------------------------|
   | ~test_cshrink~               | Test that the bounds of a capability are correctly updated                 |
   | ~test_csealuninit~           | Test that a sealed capability can't be mutated by trying to make it uninit |
   | ~test_uninit~                | Test that the cuninit instruction makes a capability uninitialized         |
   | ~test_uninit_cap_csetaddr~   | Test that the address of an uninitialized capability cannot be lowered     |
   | ~test_uninit_cap_offset~     | Test that offsets are updated correctly and that offset cannot be lowered  |
   | ~test_uninit_cap_ucstore~    | Test that the UCS[BHWD] works as expected                                  |
   | ~test_uninit_cap_ucstorecap~ | Similar to ~test_uninit_cap_ucstore~                                       |
   
   I will discuss one test in more detail, ~test_cshrink~, to give the reader of the thesis a better
   understanding of how these are written. This will make it easier to inspect the test files
   yourself and will come in handy for the second evaluation. 
   
   The ~test_cshrink~ test exists of two files, the assembly file containing the instructions to be
   run on the machine (~test_cshrink.s~) and a python file (~test_cshrink.py~)to make assertions 
   on the log file produced by the simulator.
   
   The assembly file exists of two parts, one part is the test instructions to be executed,
   wrapped in the ~BEGIN_TEST~ and ~END_TEST~ macros and the second part is data part, which
   will be used to create a capability for and write to/read from. The data part defines a
   few words and is further not important to understand the test. I will focus on the first part,
   the test instructions:
   #+begin_src cherimips -n
   cgetdefault $c1
   dla $t0, data
   csetoffset $c1, $c1, $t0
   csetboundsimm $c1, $c1, 10
   cincoffsetimm $c1, $c1, 8
   cgetbase $t0, $c1

   cshrink $c2, $c1, 0 # length of $c2 = offset = 8
   dli $s0, 10
   ucsb $c2, $s0, -1($c2)
   cgetlen $a0, $c1
   cgetlen $a1, $c2
   cgetbase $t3, $c2

   csetoffset $c1, $c1, $a0
   cincoffset $c1, $c1, 1
   cshrink $c3, $c1, 0 # error: shrinking with offset out of bounds shouldn't work

   cincoffset $c4, $c1, -10
   cshrink $c4, $c4, $t0
   cgetbase $t1, $c4
   cgetlen $a2, $c4

   cincoffset $c5, $c1, -1 # cursor will now be on end 
   cshrink $c5, $c5, 0
   cgetlen $a3, $c5
   cshrink $c6, $c5, 1
   cgetbase $t2, $c6
   ucsb $c5, $s0, -1($c5)
   #+end_src
   
   Lines 1-6 setup the capability and store the base of /$c1/ into /$t0/. Next, a cshrink instruction
   is issued to shrink the capability /$c1/ to a capability with the same base but with as end the
   current cursor of /$c1/. A store instruction follows, to make sure no error is thrown after
   shrinking a capability. Then some values of /$c1/ and /$c2/ are stored in registers /$a0/, /$a1/
   and /$t3/.
   On lines 15-17, the cursor of the capability is set to the end of the capability and right after
   that is incremented by one. This means that the cursor is now out of bounds ($cursor > end$) and
   shrinking the capability should raise an error.
   The remaining instructions are similar to those discussed earlier.
   
   It is now clear what the assembly test instructions do. What remains to be explained is the
   test cases written in the python file:
   #+begin_src python -n
   from beritest_tools import BaseBERITestCase

   class test_cshrink(BaseBERITestCase):
      EXPECTED_EXCEPTIONS = 1

      def test_cshrink_lowers_end(self):
         '''Test that lowering the end of a capability works'''
         assert self.MIPS.a0 == 10
         assert self.MIPS.a1 == 8
         assert self.MIPS.a1 < self.MIPS.a0
         assert self.MIPS.a2 == 1

      def test_cshrink_with_cursor_at_end_does_nothing(self):
         '''Test that using cshrink with a capability for which cursor=end does not change end'''
         assert self.MIPS.a0 == self.MIPS.a3

      def test_cshrink_increases_base(self):
         assert self.MIPS.t0 == self.MIPS.t1
         assert self.MIPS.t0 == self.MIPS.t3
         assert self.MIPS.t0 + 1 == self.MIPS.t2
   #+end_src

   The test class needs to be the same name as the file (~test_cshrink~) and subclasses 
   ~BaseBERITestCase~ (which gives it easy access to the contents of the log file for this
   test). The ~EXPECTED_EXCEPTIONS~ is declared to be one (the error that is expected as explained
   in the assembly file discussion). Three methods are defined, the first methods, 
   ~test_cshrink_lowers_end~ tests that the cshrink instruction correctly lowers the end
   of a capability. Here you can see why subclassing ~BaseBERITestCase~ is useful, the registers
   can be addressed as ~self.MIPS.a0~. The second method, ~test_cshrink_with_cursor_at_end_does_nothing~
   tests that shrinking a capability (in which we don't change the base of the capability) with its
   cursor already at the end does not change the end of the capability. The last method,
   ~test_cshrink_increases_base~ is similar to ~test_cshrink_lowers_end~.

** Calling Convention 
   # TODO
   # What kind of evaluations were done?
   # - Semantics preserved (old cc & new cc have same outputs)
   # - Stats: epilogue/prologue nr of instrs, call invocation?
   # - Execution time (simple wrapper around test that measures execution time? remove log files before running tests)
   # Where to find these tests? (going over each of them would take too much space?)
   # Present the C examples -> explain what they do, what they show, why they are relevant, ...
   

